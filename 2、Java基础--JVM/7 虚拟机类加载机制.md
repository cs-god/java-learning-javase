# 虚拟机类加载机制

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载，验证，准备，解析，初始化，使用和卸载七个阶段，其中验证，准备，解析三个部分统称为连接。

其中，加载，验证，准备，初始化，卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段开始之后再开始。



## 类加载的过程

### 加载

在加载阶段，Java虚拟机需要完成以下三件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法去这个类的各种数据的访问入口。

**非数组类**和**数组类**的加载阶段有所不同：

**非数组类加载阶段**。既可以使用虚拟机内置的启动类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。

**数组类加载阶段**。数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。但是数组的**元素类型**(*Element Type*，指的是**去掉所有维度**的类型）最终还是要靠类加载器来完成加载，一个数组类（下面简称**C**）创建过程遵循以下规则：

- 如果数组的组件类型（*Component Type*，指的是数组**去掉一个维度**的类型，注意和前面的元素类型区分开来）是引用类型，那就递归采用本节定义的加载过程去加载这个组件类型，数组**C**将被标志在加载该组件类型的类加载器的类名称空间上。
- 如果数组的组件类型不是引用类型，Java虚拟机将会把数组C标记为与启动类加载器关联。
- 数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，嗑呗所有的类和接口访问到。

加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机设定的格式存储在方法区中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class对象，这个对象将作为程序访问方法区中的类型数据的外部接口。

加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，**这两个阶段的开始时间**仍然保持着固定的先后顺序。



### 验证

目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害**虚拟机自身**的安全。

#### 文件格式验证

第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包含下面这些验证点：

- 是否以魔数oxCAFEBABE开头。
- 主次版本号是否在当前Java虚拟机接受范围之内。
- 常量池中的常量中是否有不被支持的常量类型。
- CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。
- 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
- Class文件中各部分及文件本身是否有被删除的或附加的其他信息。
- ......

该验证阶段的主要目的是保证输入的字节流能被正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。

这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法去的存储结构上进行的，不会再直接读取 操作字节流了。

#### 元数据验证

第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java虚拟机规范》的要求。这一阶段可能包含下面这些验证点：f



## 类加载器