
# 一、加载器种类

## 1）启动类加载器(Bootstrap ClassLoader)

	用C/C++实现，通常由与os相关的本地代码实现，没有对应的java对象，在java中由null代替。JVM启动时创建，

1> JDK8中，将如下内容中的类加载到内存中：
- `<JAVA_ HOME>/jre/lib`
- `-Xbootclasspath参数指定的路径`

需要注意的是，只加载指定名称的内容：
- Obejct、System、String等。
- java运行时的rt.jar等jar包。
- 系统属性sun.boot.class.path指定的目录中特定名称的jar包

2> JDK9 以后，Bootstrap ClassLoader 主要用来加载 java.base 中的核心系统类。
-- --
## 2）扩展类加载器(ExtClassLoader)

1> JDK8中，用来加载  `${JAVA_HOME}/lib/ext` 目录下的类。
2> JDK9以后，已经被移除。
-- --
## 3）模块加载器(PlatformClassLoader)：

JDK9以后，用来代替 ExtClassLoader，用来加载 jdk 中的非核心模块类。如：
- `java.scripting`
- `java.compiler*`
- `java.corba*`

## 4）应用程序类加载器(AppClassLoader)：

1> JDK8中，负责加载如下所有类库：
- 环境变量ClassPath
- 系统属性java.class.path指定目录
- 虚拟机参数-cp/-classpath指定目录

2> JDK9以后，用于加载应用级别的模块，如：
- `jdk.compiler`
- `jdk.jartool`
- `jdk.jshell`

# 源码

源码探究使用 jdk11，与 jdk8 中的有些许不同。

## ClassLoader

ClassLoader 是类加载器的顶级父类，其核心的方法主要是 loadClass(...) 方法：

```java
// ClassLoader.class
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException{
    // 加锁，保证线程安全
    synchronized (getClassLoadingLock(name)) {
        // 先去找一次 class 是否已经被加载了，如果已经被加载了就不用重复加载了
        // 此方法的核心逻辑由 c++ 实现
        Class<?> c = findLoadedClass(name);
        // 没有被加载的情况
        if (c == null) {
            long t0 = System.nanoTime(); // 记录时间
            try {
                // 此处体现双亲委派机制
                // 如果该加载器存在父加载器，就会先去调用父加载器的相关方法
                // 如果没有父加载器，就去调用 Bootstrap 加载器
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    // 调用 BootstrapClassLoader，此方法的核心逻辑是 c++ 实现的
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {

            }

            // 如果依旧加载不到，那么就说明父加载器仍然加载不到信息
            // 那么就需要指定的加载器自己去加载了
            if (c == null) {

                long t1 = System.nanoTime();
                
                // 该加载器加载类文件的核心逻辑
                // 该方法在 ClassLoader 中是留空的，需要子类按照自身的逻辑去实现
                c = findClass(name);

                // 此处做一些信息记录，和主逻辑无关
                PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                PerfCounter.getFindClasses().increment();
            }
        }
        
        if (resolve) {
            // 解析 class，也是留空的，需要子类去实现
            resolveClass(c);
        }
        return c;
    }
}

```

## 

BuiltinClassLoader 是 jdk9 中代替 URLClassLoader 的加载器，是 PlatformClassLoader 与 AppClassLoader 的父类。其继承了 SecureClassLoader，其核心的方法主要是 loadClassOrNull(...) 方法：

```java
// BuiltinClassLoader.class

// step 1
@Override
protected Class<?> loadClass(String cn, boolean resolve) throws ClassNotFoundException{
    // 复写了 loadClass(...) 方法，但是核心是调用 loadClassOrNull(...)
    Class<?> c = loadClassOrNull(cn, resolve);
    if (c == null)
        throw new ClassNotFoundException(cn);
    return c;
}

// step 2
protected Class<?> loadClassOrNull(String cn, boolean resolve) {
    // 加锁，保证线程安全
    synchronized (getClassLoadingLock(cn)) {
        // 先去找一次 class 是否已经被加载了，此方法是 ClassLoader 中的
        Class<?> c = findLoadedClass(cn);

        if (c == null) {

            // 这里会需要去先加载模块信息
            LoadedModule loadedModule = findLoadedModule(cn);
            if (loadedModule != null) {
                BuiltinClassLoader loader = loadedModule.loader();
                if (loader == this) {
                    if (VM.isModuleSystemInited()) {
                        c = findClassInModuleOrNull(loadedModule, cn);
                    }
                } else {
                    c = loader.loadClassOrNull(cn);
                }
            } else {

                // 先调用父加载器的相关方法去加载一次
                if (parent != null) {
                    c = parent.loadClassOrNull(cn);
                }

                // 如果没加载到，则用当前加载器去加载
                if (c == null && hasClassPath() &&　VM.isModuleSystemInited(){
                    // 此方法内会调用到 defineClass(...) 方法去加载类文件
                    c = findClassOnClassPathOrNull(cn);
                }
            }

        }

        // 解析 class
        if (resolve && c != null)
            resolveClass(c);

        return c;
    }
}
```

该加载器中还有一个加载 class 字节码的方法：

```java
// BuiltinClassLoader.class
private Class<?> defineClass(String cn, Resource res) throws IOException{
    
    URL url = res.getCodeSourceURL();

    // 先解析这个 class 的路径
    int pos = cn.lastIndexOf('.');
    if (pos != -1) {
        String pn = cn.substring(0, pos);
        Manifest man = res.getManifest();
        defineOrCheckPackage(pn, man, url);
    }

    // 这里会将 class 读取出来成一个 byte[] 字符串，并通过 jvm 的相关方法去加载
    ByteBuffer bb = res.getByteBuffer();
    if (bb != null) {
        CodeSigner[] signers = res.getCodeSigners();
        CodeSource cs = new CodeSource(url, signers);
        // 该方法最后会调用 ClassLoader 内的 native 方法
        return defineClass(cn, bb, cs);
    } else {
        byte[] b = res.getBytes();
        CodeSigner[] signers = res.getCodeSigners();
        CodeSource cs = new CodeSource(url, signers);
        // 该方法最后会调用 ClassLoader 内的 native 方法
        return defineClass(cn, b, 0, b.length, cs);
    }
}
```

## BootClassLoader

BootClassLoader 是 ClassLoaders 的一个静态内部类，虽然它从代码实现上是 BuiltinClassLoader 的子类，但是从功能上说它是 PlatformClassLoader 的 parent 类：

```java
// ClassLoader.class
private static class BootClassLoader extends BuiltinClassLoader {
    BootClassLoader(URLClassPath bcp) {
        super(null, null, bcp);
    }

    // 复写了 BuiltinClassLoader 中的 loadClassOrNull(...) 方法
    @Override
    protected Class<?> loadClassOrNull(String cn) {
        return JLA.findBootstrapClassOrNull(this, cn);
    }
};
```

## PlatformClassLoader

PlatformClassLoader 也是 ClassLoaders 的一个静态内部类，从功能上说它是 BootClassLoader 的子类，同时也是 AppClassLoader 的 parent 类。PlatformClassLoader 主要用来加载一些 module：

```java
// ClassLoader.class
private static class PlatformClassLoader extends BuiltinClassLoader {
    static {
        if (!ClassLoader.registerAsParallelCapable())
            throw new InternalError();
    }

    // 此处会将 BootClassLoader 作为 parent 参数传入进去
    PlatformClassLoader(BootClassLoader parent) {
        super("platform", parent, null);
    }

    // 加载 module
    private Package definePackage(String pn, Module module) {
        return JLA.definePackage(this, pn, module);
    }
}
```

### AppClassLoader

Main线程的类加载器（Thread.currentThread().getContextClassLoader()）就是AppClassLoader。

AppClassLoader 的核心方法是 loadClass(...)，最终会调用到 BuiltinClassLoader.loadClassOrNull(...) 方法，而此方法内部又会调用到 PlatformClassLoader.loadClass(...) 方法；然后实际上 PlatformClassLoader 内部又会去调用 BootClassLoader 的 loadClassOrNull(...) 方法。这种方式下就完成类加载器的双亲委派机制：
```java
// ClassLoader.class
private static class AppClassLoader extends BuiltinClassLoader {
    static {
        if (!ClassLoader.registerAsParallelCapable())
            throw new InternalError();
    }

    final URLClassPath ucp;

    // 此处会将 PlatformClassLoader 作为 parent 参数传入进去
    AppClassLoader(PlatformClassLoader parent, URLClassPath ucp) {
        super("app", parent, ucp);
        this.ucp = ucp;
    }

    @Override
    protected Class<?> loadClass(String cn, boolean resolve) throws ClassNotFoundException{
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            int i = cn.lastIndexOf('.');
            if (i != -1) {
                sm.checkPackageAccess(cn.substring(0, i));
            }
        }
        // 实际上是调用了 BuiltinClassLoader.loadClassOrNull(...) 方法
```
